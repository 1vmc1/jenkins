pipeline {
  agent { label 'vmc2' }

  environment {
    TARGET_HOST    = '192.168.199.253'
    TARGET_USER    = 'ununtu'
    SSH_KEY        = '/home/ubuntu/.ssh/mac'
    IMAGE_NAME     = 'myorg/myapp'
    IMAGE_TAG      = '14'
    CONTAINER_NAME = 'myapp'
    BUILD_JOB_WS   = '/home/ubuntu/agent/workspace/my-java-pipeline'
  }

  stages {
    stage('Get Artifact from build workspace') {
      steps {
        sh """
          ls -lh ${BUILD_JOB_WS}
          cp ${BUILD_JOB_WS}/myorg_myapp_${IMAGE_TAG}.tar .
          ls -lh
        """
      }
    }

    stage('Transfer Image to Target Server') {
      steps {
        sh """
          scp -i ${SSH_KEY} -o StrictHostKeyChecking=no \\
            myorg_myapp_${IMAGE_TAG}.tar \\
            ${TARGET_USER}@${TARGET_HOST}:/tmp/
        """
      }
    }

    stage('Deploy on Target Server') {
      steps {
        sh """
          ssh -i ${SSH_KEY} -o StrictHostKeyChecking=no \\
            ${TARGET_USER}@${TARGET_HOST} \\
            'bash -s' <<'ENDSSH'

          set -e

          IMAGE_NAME='${IMAGE_NAME}'
          IMAGE_TAG='${IMAGE_TAG}'
          CONTAINER_NAME='${CONTAINER_NAME}'

          # Загружаем образ
          docker load -i /tmp/myorg_myapp_${IMAGE_TAG}.tar

          # Останавливаем и удаляем старый контейнер (если есть)
          docker stop ${CONTAINER_NAME} 2>/dev/null || true
          docker rm ${CONTAINER_NAME} 2>/dev/null || true

          # Запускаем новый контейнер
          docker run -d \\
            --name ${CONTAINER_NAME} \\
            -p 8080:8080 \\
            ${IMAGE_NAME}:${IMAGE_TAG}

          docker ps | grep ${CONTAINER_NAME} || (echo "Container not running" && exit 1)

          echo "Deployment complete. App running on port 8080."
ENDSSH
        """
      }
    }
  }

  post {
    success {
      echo "Application deployed successfully to ${TARGET_HOST}:8080"
    }
    failure {
      echo "Deployment failed. Check logs."
    }
  }
}
